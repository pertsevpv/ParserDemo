# ScopeGraphs

## Структура

### ScopeGraph

ScopeGraph состоит из:

1. ScopeNode root - корневой ScopeNode
2. Interval tree - дерево интервалов. Содержит разбиение документа на интервалы, которые следует перепарсить при
   редактировании документа. Состоит из IntervalNode, содержащих интервал в документе, а также соответствующий ему
   ScopeNode
3. Map<String, List\<String\>> typeMap - Map, хранящая в себе информацию о наследваниях. Ключ - класс, значение - список
   его суперклассов

### ScopeNode

Основным компонентом ScopeGraph'а является ScopeNode. ScopeNode состоит из:

1. ScopeNode parent - родитель ScopeNode
2. List\<ScopeNode\> children - список детей ScopeNode
3. List\<DeclNode\> declarations - список объявлений переменных, для которых известен тип. Пример - int a = 10;
4. List\<RefNode\> references - список нерешенных ccылок на объявления. Пример - foo(a).
5. List\<InferenceNode\> inferences - список пар \<DeclNode, RefNode\>. Необходимы для того, когда тип объявления
   зависит от присвоенного ему выражения. Пример - var a = foo();
6. String type. Если текущий ScopeNode соответсвует классу, то type будет названием текущего класса. Иначе - null

Также, кроме стандартного, существуют следующие типы ScopeNode:

1. FakeNode - необходим когда интервальное дерево должно содержать интервал, из которого нельзя составить корректный
   ScopeNode. Пример - комментарии, макросы
2. MemberNode - необходим когда ScopeNode является классом, чьи члены должны быть учтены при обходе declarations.

### DeclNode

DeclNode бывает двух типов:

1. DeclNode - объявление переменной/поля/аргумента функции
2. MethodNode - объявление конструктора/метода

### RefNode

RefNode бывает следующих типов:

1. RefNode - самое простое обращение.
2. CallNode - обращение к методу/конструктору. Содержит в себе аргументы вызова. Сначала резолвятся аргументы, затем
   среди MethodNode ищем подходящий по типам
   CallNode
3. QualifiedRefNode - обращение вида a.b().c; Состоит из RefNode begin, cont. Сначала резолвится begin. Если begin был
   зарезолвен и для него был определен тип, то запускаем резолв cont из cooтветсвующего типу ScopeNode.
4. ExpressionRef - обращение, состоящее из нескольких RefNode. RefNode резолвятся подряд

### Алгоритм

Общий порядок резолва:

1. Поиск в текущих declaration. Для текущей ScopeNode declarations получаются из:
    * this.declaration
    * inferences.map(inferences.decl)
    * children.filter(isMember).flatMap(member.declarations)
2. В случае если текущий ScopeNode обозначает класс, то проверяются члены суперклассов
3. В противном случае ищем в родителях

## Построение

Новые ScopeNode создаются при:

1. Заходе в объявления пакета, импортов (в Java, создается FakeNode)
2. Заходе в объявления типа
3. Заходе в член класса (для полей/методов/конструкторов создается MemberNode вместе с соостветствующими объявлениями)
4. Заходе в аргументы метода/конструктора
5. Заходе в блок

Новые IntervalNode создаются при

1. Объявлении пакета, импортов (в Java)
2. Объявлении типа
3. Объявлении члена класса

К текущему ScopeNode добавляются:

* DeclNode:
    1. При объявлении локальной переменной
    2. При объявлении аргументов метода/конструктора
* RefNode:
    1. При присваивании переменной
    2. При посещении statement
    3. При вызове в аргументах метода/конструктора
* InferenceNode:
    1. При выведении типа локальной переменной
